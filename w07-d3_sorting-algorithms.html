<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>;
<h1 id="week-07-day-3-sorting-algorithms" data-ignore="true">WEEK-07 DAY-3<br><em>Sorting Algorithms</em></h1>
<hr />
<h1 id="bubble-sort">Bubble Sort</h1>
<p>Bubble Sort is generally the first major sorting algorithm to come up in most introductory programming courses. Learning about this algorithm is useful educationally, as it provides a good introduction to the challenges you face when tasked with converting unsorted data into sorted data, such as conducting logical comparisons, making swaps while iterating, and making optimizations. It’s also quite simple to implement, and can be done quickly.</p>
<p>Bubble Sort is <em>almost never</em> a good choice in production. simply because:</p>
<ul>
<li>It is not efficient</li>
<li>It is not commonly used</li>
<li>There is a stigma attached to using it</li>
</ul>
<h2 id="butthenwhy-are-we"><em>“But…then…why are we…”</em></h2>
<p>It is <em>quite useful</em> as an educational base for you, and as a conversational base for you while interviewing, because you can discuss how other more elegant and efficient algorithms improve upon it. Taking naive code and improving upon it by weighing the technical tradeoffs of your other options is 100% the name of the game when trying to level yourself up from a junior engineer to a senior engineer.</p>
<h2 id="the-algorithm-bubbles-up">The algorithm bubbles up</h2>
<p>As you progress through the algorithms and data structures of this course, you’ll eventually notice that there are some recurring funny terms. “Bubbling up” is one of those terms.</p>
<p>When someone writes that an item in a collection “bubbles up,” you should infer that:</p>
<ul>
<li>The item is <em>in motion</em></li>
<li>The item is moving <em>in some direction</em></li>
<li>The item <em>has some final resting destination</em></li>
</ul>
<p>When invoking Bubble Sort to sort an array of integers in ascending order, the largest integers will “bubble up” to the “top” (the end) of the array, one at a time.</p>
<p>The largest values are captured, put into motion in the direction defined by the desired sort (ascending right now), and traverse the array until they arrive at their end destination. See if you can observe this behavior in the following animation (courtesy http://visualgo.net):</p>
<figure>
<img src="images/BubbleSort.gif" alt="bubble sort" /><figcaption>bubble sort</figcaption>
</figure>
<p>As the algorithm iterates through the array, it compares each element to the element’s right neighbor. If the current element is larger than its neighbor, the algorithm swaps them. This continues until all elements in the array are sorted.</p>
<h2 id="how-does-a-pass-of-bubble-sort-work">How does a pass of Bubble Sort work?</h2>
<p>Bubble sort works by performing multiple <em>passes</em> to move elements closer to their final positions. A single pass will iterate through the entire array once.</p>
<p>A pass works by scanning the array from left to right, two elements at a time, and checking if they are ordered correctly. To be ordered correctly the first element must be less than or equal to the second. If the two elements are not ordered properly, then we swap them to correct their order. Afterwards, it scans the next two numbers and continue repeat this process until we have gone through the entire array.</p>
<p>See one pass of bubble sort on the array <code>[2, 8, 5, 2, 6]</code>. On each step the elements currently being scanned are in <strong>bold</strong>.</p>
<ul>
<li>[<strong>2</strong>, <strong>8</strong>, 5, 2, 6] - ordered, so leave them alone</li>
<li>[2, <strong>8</strong>, <strong>5</strong>, 2, 6] - not ordered, so swap</li>
<li>[2, 5, <strong>8</strong>, <strong>2</strong>, 6] - not ordered, so swap</li>
<li>[2, 5, 2, <strong>8</strong>, <strong>6</strong>] - not ordered, so swap</li>
<li>[2, 5, 2, 6, 8] - the first pass is complete</li>
</ul>
<p>Because at least one swap occurred, the algorithm knows that it wasn’t sorted. It needs to make another pass. It starts over again at the first entry and goes to the next-to-last entry doing the comparisons, again. It only needs to go to the next-to-last entry because the previous “bubbling” put the largest entry in the last position.</p>
<ul>
<li>[<strong>2</strong>, <strong>5</strong>, 2, 6, 8] - ordered, so leave them alone</li>
<li>[2, <strong>5</strong>, <strong>2</strong>, 6, 8] - not ordered, so swap</li>
<li>[2, 2, <strong>5</strong>, <strong>6</strong>, 8] - ordered, so leave them alone</li>
<li>[2, 2, 5, 6, 8] - the second pass is complete</li>
</ul>
<p>Because at least one swap occurred, the algorithm knows that it wasn’t sorted. Now, it can bubble from the first position to the last-2 position because the last two values are sorted.</p>
<ul>
<li>[<strong>2</strong>, <strong>2</strong>, 5, 6, 8] - ordered, so leave them alone</li>
<li>[2, <strong>2</strong>, <strong>5</strong>, 6, 8] - ordered, so leave them alone</li>
<li>[2, 2, 5, 6, 8] - the third pass is complete</li>
</ul>
<p>No swap occurred, so the Bubble Sort stops.</p>
<h2 id="ending-the-bubble-sort">Ending the Bubble Sort</h2>
<p>During Bubble Sort, you can tell if the array is in sorted order by checking if a swap was made during the previous pass performed. If a swap was not performed during the previous pass, then the array must be totally sorted and the algorithm can stop.</p>
<p>You’re probably wondering why that makes sense. Recall that a pass of Bubble Sort checks if any adjacent elements are <strong>out of order</strong> and swaps them if they are. If we don’t make any swaps during a pass, then everything must be already <strong>in order</strong>, so our job is done. Let that marinate for a bit.</p>
<h2 id="pseudocode-for-bubble-sort">Pseudocode for Bubble Sort</h2>
<pre><code>Bubble Sort: (array)
  n := length(array)
  repeat
  swapped = false
  for i := 1 to n - 1 inclusive do

      /* if this pair is out of order */
      if array[i - 1] &gt; array[i] then

        /* swap them and remember something changed */
        swap(array, i - 1, i)
        swapped := true

      end if
    end for
  until not swapped</code></pre>
<hr />
<h1 id="selection-sort">Selection Sort</h1>
<p>Selection Sort is very similar to Bubble Sort. The major difference between the two is that Bubble Sort bubbles the <em>largest</em> elements up to the end of the array, while Selection Sort selects the <em>smallest</em> elements of the array and directly places them at the beginning of the array in sorted position. Selection sort will utilize swapping just as bubble sort did. Let’s carefully break this sorting algorithm down.</p>
<h2 id="the-algorithm-select-the-next-smallest">The algorithm: select the next smallest</h2>
<p>Selection sort works by maintaining a sorted region on the left side of the input array; this sorted region will grow by one element with every “pass” of the algorithm. A single “pass” of selection sort will select the next smallest element of unsorted region of the array and move it to the sorted region. Because a single pass of selection sort will move an element of the unsorted region into the sorted region, this means a single pass will shrink the unsorted region by 1 element whilst increasing the sorted region by 1 element. Selection sort is complete when the sorted region spans the entire array and the unsorted region is empty!</p>
<figure>
<img src="images/SelectionSort.gif" alt="selection sort" /><figcaption>selection sort</figcaption>
</figure>
<p>The algorithm can be summarized as the following:</p>
<ol type="1">
<li>Set MIN to location 0</li>
<li>Search the minimum element in the list</li>
<li>Swap with value at location MIN</li>
<li>Increment MIN to point to next element</li>
<li>Repeat until list is sorted</li>
</ol>
<h2 id="the-pseudocode">The pseudocode</h2>
<p>In pseudocode, the Selection Sort can be written as this.</p>
<pre><code>procedure selection sort
   list  : array of items
   n     : size of list

   for i = 1 to n - 1
   /* set current element as minimum*/
      min = i

      /* check the element to be minimum */

      for j = i+1 to n
         if list[j] &lt; list[min] then
            min = j;
         end if
      end for

      /* swap the minimum element with the current element*/
      if indexMin != i  then
         swap list[min] and list[i]
      end if
   end for
end procedure</code></pre>
<hr />
<h1 id="insertion-sort">Insertion Sort</h1>
<p>With Bubble Sort and Selection Sort now in your tool box, you’re starting to get some experience points under your belt! Time to learn one more “naive” sorting algorithm before you get to the efficient sorting algorithms.</p>
<h2 id="the-algorithm-insert-into-the-sorted-region">The algorithm: insert into the sorted region</h2>
<p>Insertion Sort is similar to Selection Sort in that it gradually builds up a larger and larger sorted region at the left-most end of the array.</p>
<p>However, Insertion Sort differs from Selection Sort because this algorithm does not focus on searching for the right element to place (the next smallest in our Selection Sort) on each pass through the array. Instead, it focuses on sorting each element in the order they appear from left to right, regardless of their value, and inserting them in the most appropriate position in the sorted region.</p>
<p>See if you can observe the behavior described above in the following animation:</p>
<figure>
<img src="images/InsertionSort.gif" alt="insertion sort" /><figcaption>insertion sort</figcaption>
</figure>
<h2 id="the-steps">The Steps</h2>
<p>Insertion Sort grows a sorted array on the left side of the input array by:</p>
<ol type="1">
<li>If it is the first element, it is already sorted. return 1;</li>
<li>Pick next element</li>
<li>Compare with all elements in the sorted sub-list</li>
<li>Shift all the elements in the sorted sub-list that is greater than the value to be sorted</li>
<li>Insert the value</li>
<li>Repeat until list is sorted</li>
</ol>
<p>These steps are easy to confuse with selection sort, so you’ll want to watch the video lecture and drawing that accompanies this reading as always!</p>
<h2 id="the-pseudocode-1">The pseudocode</h2>
<pre><code>procedure insertionSort( A : array of items )
   int holePosition
   int valueToInsert

   for i = 1 to length(A) inclusive do:

      /* select value to be inserted */
      valueToInsert = A[i]
      holePosition = i

      /*locate hole position for the element to be inserted */

      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:
         A[holePosition] = A[holePosition-1]
         holePosition = holePosition -1
      end while

      /* insert the number at hole position */
      A[holePosition] = valueToInsert

   end for

end procedure</code></pre>
<hr />
<h1 id="merge-sort">Merge Sort</h1>
<p>You’ve explored a few sorting algorithms already, all of them being quite slow with a runtime of O(n<sup>2</sup>). It’s time to level up and learn your first time-efficient sorting algorithm! You’ll explore <strong>merge sort</strong> in detail soon, but first, you should jot down some key ideas for now. The following points are not steps to an algorithm yet; rather, they are ideas that will motivate how you can derive this algorithm.</p>
<ul>
<li>it is easy to merge elements of two sorted arrays into a single sorted array</li>
<li>you can consider an array containing only a single element as already trivially sorted</li>
<li>you can also consider an empty array as trivially sorted</li>
</ul>
<h2 id="the-algorithm-divide-and-conquer">The algorithm: divide and conquer</h2>
<p>You’re going to need a helper function that solves the first major point from above. How might you merge two sorted arrays? In other words you want a <code>merge</code> function that will behave like so:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">let</span> arr1 <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">15</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">let</span> arr2 <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">10</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="at">merge</span>(arr1<span class="op">,</span> arr2)<span class="op">;</span> <span class="co">// =&gt; [0, 1, 2, 3, 5, 7, 10, 10, 15]</span></a></code></pre></div>
<p>Once you have that, you get to the “divide and conquer” bit.</p>
<p>The algorithm for merge sort is actually <em>really</em> simple.</p>
<ol type="1">
<li>if there is only one element in the list, it is already sorted. return that array.</li>
<li>otherwise, divide the list recursively into two halves until it can no more be divided.</li>
<li>merge the smaller lists into new list in sorted order.</li>
</ol>
<p>The process is visualized below. When elements are moved to the bottom of the picture, they are going through the <code>merge</code> step:</p>
<figure>
<img src="images/MergeSort.gif" alt="merge sort" /><figcaption>merge sort</figcaption>
</figure>
<p>The pseudocode for the algorithm is as follows.</p>
<pre><code>procedure mergesort( a as array )
   if ( n == 1 ) return a

   /* Split the array into two */
   var l1 as array = a[0] ... a[n/2]
   var l2 as array = a[n/2+1] ... a[n]

   l1 = mergesort( l1 )
   l2 = mergesort( l2 )

   return merge( l1, l2 )
end procedure

procedure merge( a as array, b as array )
   var result as array
   while ( a and b have elements )
      if ( a[0] &gt; b[0] )
         add b[0] to the end of result
         remove b[0] from b
      else
         add a[0] to the end of result
         remove a[0] from a
      end if
   end while

   while ( a has elements )
      add a[0] to the end of result
      remove a[0] from a
   end while

   while ( b has elements )
      add b[0] to the end of result
      remove b[0] from b
   end while

   return result
end procedure</code></pre>
<hr />
<h1 id="quick-sort">Quick Sort</h1>
<p>Quick Sort has a similar “divide and conquer” strategy to Merge Sort. Here are a few key ideas that will motivate the design:</p>
<ul>
<li>it is easy to sort elements of an array relative to a particular target value</li>
<li>an array of 0 or 1 elements is already trivially sorted</li>
</ul>
<p>Regarding that first point, for example given <code>[7, 3, 8, 9, 2]</code> and a target of <code>5</code>, we know <code>[3, 2]</code> are numbers less than <code>5</code> and <code>[7, 8, 9]</code> are numbers greater than <code>5</code>.</p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>In general, the strategy is to divide the input array into two subarrays: one with the smaller elements, and one with the larger elements. Then, it recursively operates on the two new subarrays. It continues this process until of dividing into smaller arrays until it reaches subarrays of length 1 or smaller. As you have seen with Merge Sort, arrays of such length are automatically sorted.</p>
<p>The steps, when discussed on a high level, are simple:</p>
<ol type="1">
<li>choose an element called “the pivot”, how that’s done is up to the implementation</li>
<li>take two variables to point left and right of the list excluding pivot</li>
<li>left points to the low index</li>
<li>right points to the high</li>
<li>while value at left is less than pivot move right</li>
<li>while value at right is greater than pivot move left</li>
<li>if both step 5 and step 6 does not match swap left and right</li>
<li>if left ≥ right, the point where they met is new pivot</li>
<li>repeat, recursively calling this for smaller and smaller arrays</li>
</ol>
<p>Before we move forward, see if you can observe the behavior described above in the following animation:</p>
<figure>
<img src="images/QuickSort.gif" alt="quick sort" /><figcaption>quick sort</figcaption>
</figure>
<h2 id="the-algorithm-divide-and-conquer-1">The algorithm: divide and conquer</h2>
<p>Formally, we want to partition elements of an array relative to a pivot value. That is, we want elements less than the pivot to be separated from elements that are greater than or equal to the pivot. Our goal is to create a function with this behavior:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">7</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="at">partition</span>(arr<span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span>  <span class="co">// =&gt; [[3, 2], [7,8,9]]</span></a></code></pre></div>
<h3 id="partition">Partition</h3>
<p>Seems simple enough! Let’s implement it in JavaScript:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// nothing fancy</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">function</span> <span class="at">partition</span>(array<span class="op">,</span> pivot) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">let</span> left <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="kw">let</span> right <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="va">array</span>.<span class="at">forEach</span>(el <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="cf">if</span> (el <span class="op">&lt;</span> pivot) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-8" title="8">      <span class="va">left</span>.<span class="at">push</span>(el)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-10" title="10">      <span class="va">right</span>.<span class="at">push</span>(el)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14">  <span class="cf">return</span> [ left<span class="op">,</span> right ]<span class="op">;</span></a>
<a class="sourceLine" id="cb7-15" title="15"><span class="op">}</span></a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="co">// if you fancy</span></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="kw">function</span> <span class="at">partition</span>(array<span class="op">,</span> pivot) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-19" title="19">  <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-20" title="20">  <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-21" title="21">  <span class="cf">return</span> [ left<span class="op">,</span> right ]<span class="op">;</span></a>
<a class="sourceLine" id="cb7-22" title="22"><span class="op">}</span></a></code></pre></div>
<p>You don’t have to use an explicit <code>partition</code> helper function in your Quick Sort implementation; however, we will borrow heavily from this pattern. As you design algorithms, it helps to think about key patterns in isolation, although your solution may not feature that exact helper. Some would say we like to divide and conquer.</p>
<h2 id="the-pseudocode-2">The pseudocode</h2>
<p>It is <em>so</em> small, this algorithm. It’s amazing that it performs so well with so little code!</p>
<pre><code>procedure quickSort(left, right)

  if the length of the array is 0 or 1, return the array

  set the pivot to the first element of the array
  remove the first element of the array

  put all values less than the pivot value into an array called left
  put all values greater than the pivot value into an array called right

  call quick sort on left and assign the return value to leftSorted
  call quick sort on right and assign the return value to rightSorted

  return the concatenation of leftSorted, the pivot value, and rightSorted

end procedure</code></pre>
<hr />
<h1 id="binary-search">Binary Search</h1>
<p>We’ve explored many ways to sort arrays so far, but why did we go through all of that trouble? By sorting elements of an array, we are organizing the data in a way that gives us a quick way to look up elements later on. For simplicity, we have been using arrays of numbers up until this point. However, these sorting concepts can be generalized to other data types. For example, it would be easy to modify our comparison-based sorting algorithms to sort strings: instead of leveraging facts like <code>0 &lt; 1</code>, we can say <code>'A' &lt; 'B'</code>.</p>
<p>Think of a dictionary. A dictionary contains alphabetically sorted words and their definitions. A dictionary is pretty much only useful if it is ordered in this way. Let’s say you wanted to look up the definition of “stupendous.” What steps might you take?</p>
<ul>
<li>you open up the dictionary at the roughly middle page
<ul>
<li>you land in the “m” section</li>
</ul></li>
<li>you know “s” comes somewhere after “m” in the book, so you disregard all pages before the “m” section. Instead, you flip to the roughly middle page between “m” and “z”
<ul>
<li>you land in the “u” section</li>
</ul></li>
<li>you know “s” comes somewhere before “u”, so you can disregard all pages after the “u” section. Instead, you flip to the roughly middle page between the previous “m” page and “u”</li>
<li>…</li>
</ul>
<p>You are essentially using the <code>binarySearch</code> algorithm in the real world.</p>
<h2 id="the-algorithm-check-the-middle-and-half-the-search-space">The Algorithm: “check the middle and half the search space”</h2>
<p>Formally, our <code>binarySearch</code> will seek to solve the following problem:</p>
<pre><code>Given a sorted array of numbers and a target num, return a boolean indicating whether or not that target is contained in the array.</code></pre>
<p>Programmatically, we want to satisfy the following behavior:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="at">binarySearch</span>([<span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">70</span>]<span class="op">,</span> <span class="dv">12</span>)<span class="op">;</span>  <span class="co">// =&gt; true</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="at">binarySearch</span>([<span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">70</span>]<span class="op">,</span> <span class="dv">24</span>)<span class="op">;</span>  <span class="co">// =&gt; false</span></a></code></pre></div>
<p>Before we move on, really internalize the fact that <code>binarySearch</code> will only work on <strong>sorted</strong> arrays! Obviously we can search any array, sorted or unsorted, in <code>O(n)</code> time. But now our goal is be able to search the array with a sub-linear time complexity (less than <code>O(n)</code>).</p>
<h2 id="the-pseudocode-3">The pseudocode</h2>
<pre><code>procedure binary search (list, target)
  parameter list: a list of sorted value
  parameter target: the value to search for

  if the list has zero length, then return false

  determine the slice point:
    if the list has an even number of elements,
      the slice point is the number of elements
      divided by two
    if the list has an odd number of elements,
      the slice point is the number of elements
      minus one divided by two

  create an list of the elements from 0 to the
    slice point, not including the slice point,
    which is known as the &quot;left half&quot;
  create an list of the elements from the
    slice point to the end of the list which is
    known as the &quot;right half&quot;

  if the target is less than the value in the
    original array at the slice point, then
    return the binary search of the &quot;left half&quot;
    and the target
  if the target is greater than the value in the
    original array at the slice point, then
    return the binary search of the &quot;right half&quot;
    and the target
  if neither of those is true, return true
end procedure binary search</code></pre>
<hr />
<h1 id="bubble-sort-analysis">Bubble Sort Analysis</h1>
<p>Bubble Sort manipulates the array by swapping the position of two elements. To implement Bubble Sort in JS, you’ll need to perform this operation. It helps to have a function to do that. A key detail in this function is that you need an extra variable to store one of the elements since you will be overwriting them in the array:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">function</span> <span class="at">swap</span>(array<span class="op">,</span> idx1<span class="op">,</span> idx2) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="kw">let</span> temp <span class="op">=</span> array[idx1]<span class="op">;</span>     <span class="co">// save a copy of the first value</span></a>
<a class="sourceLine" id="cb12-3" title="3">  array[idx1] <span class="op">=</span> array[idx2]<span class="op">;</span>  <span class="co">// overwrite the first value with the second value</span></a>
<a class="sourceLine" id="cb12-4" title="4">  array[idx2] <span class="op">=</span> temp<span class="op">;</span>         <span class="co">// overwrite the second value with the first value</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>Note that the swap function does not create or return a new array. It mutates the original array:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">let</span> arr1 <span class="op">=</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="at">swap</span>(arr1<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3">arr1<span class="op">;</span> <span class="co">// =&gt; [ 2, 5, 8, 2, 6 ]</span></a></code></pre></div>
<h3 id="bubble-sort-js-implementation">Bubble Sort JS Implementation</h3>
<p>Take a look at the snippet below and try to understand how it corresponds to the conceptual understanding of the algorithm. Scroll down to the commented version when you get stuck.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">function</span> <span class="at">bubbleSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="kw">let</span> swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="cf">while</span>(swapped) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-5" title="5">    swapped <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">array</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-8" title="8">      <span class="cf">if</span> (array[i] <span class="op">&gt;</span> array[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-9" title="9">        <span class="at">swap</span>(array<span class="op">,</span> i<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-10" title="10">        swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-11" title="11">      <span class="op">}</span></a>
<a class="sourceLine" id="cb14-12" title="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb14-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-14" title="14"></a>
<a class="sourceLine" id="cb14-15" title="15">  <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// commented</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">function</span> <span class="at">bubbleSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="co">// this variable will be used to track whether or not we</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="co">// made a swap on the previous pass. If we did not make</span></a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="co">// any swap on the previous pass, then the array must</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="co">// already be sorted</span></a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="kw">let</span> swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9">  <span class="co">// this while will keep doing passes if a swap was made</span></a>
<a class="sourceLine" id="cb15-10" title="10">  <span class="co">// on the previous pass</span></a>
<a class="sourceLine" id="cb15-11" title="11">  <span class="cf">while</span>(swapped) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-12" title="12">    swapped <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// reset swap to false</span></a>
<a class="sourceLine" id="cb15-13" title="13"></a>
<a class="sourceLine" id="cb15-14" title="14">    <span class="co">// this for will perform a single pass</span></a>
<a class="sourceLine" id="cb15-15" title="15">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">array</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-16" title="16"></a>
<a class="sourceLine" id="cb15-17" title="17">      <span class="co">// if the two value are not ordered...</span></a>
<a class="sourceLine" id="cb15-18" title="18">      <span class="cf">if</span> (array[i] <span class="op">&gt;</span> array[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-19" title="19"></a>
<a class="sourceLine" id="cb15-20" title="20">        <span class="co">// swap the two values</span></a>
<a class="sourceLine" id="cb15-21" title="21">        <span class="at">swap</span>(array<span class="op">,</span> i<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-22" title="22"></a>
<a class="sourceLine" id="cb15-23" title="23">        <span class="co">// since you made a swap, remember that you did so</span></a>
<a class="sourceLine" id="cb15-24" title="24">        <span class="co">// b/c we should perform another pass after this one</span></a>
<a class="sourceLine" id="cb15-25" title="25">        swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-26" title="26">      <span class="op">}</span></a>
<a class="sourceLine" id="cb15-27" title="27">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-28" title="28">  <span class="op">}</span></a>
<a class="sourceLine" id="cb15-29" title="29"></a>
<a class="sourceLine" id="cb15-30" title="30">  <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb15-31" title="31"><span class="op">}</span></a></code></pre></div>
<h2 id="time-complexity-on2">Time Complexity: O(n<sup>2</sup>)</h2>
<p>Picture the worst case scenario where the input array is completely unsorted. Say it’s sorted in fully decreasing order, but the goal is to sort it in increasing order:</p>
<ul>
<li>n is the length of the input array</li>
<li>The inner <code>for</code> loop along contributes <em>O(n)</em> in isolation</li>
<li>The outer while loop contributes <em>O(n)</em> in isolation because a single iteration of the while loop will bring one element to its final resting position. In other words, it keeps running the while loop until the array is fully sorted. To fully sort the array we will need to bring all <code>n</code> elements into their final resting positions.</li>
<li>Those two loops are nested so the total time complexity is O(n * n) = O(n<sup>2</sup>).</li>
</ul>
<p>It’s worth mentioning that the best case scenario is when the input array is already fully sorted. This will cause our for loop to conduct a single pass without performing any swap, so the <code>while</code> loop will not trigger further iterations. This means best case time complexity is <em>O(n)</em> for bubble sort. This best case linear time is probably the only advantage of bubble sort. Programmers are usually interested only in the worst-case analysis and ignore best-case analysis.</p>
<h2 id="space-complexity-o1">Space Complexity: O(1)</h2>
<p>Bubble Sort is a constant space, O(1), algorithm. The amount of memory consumed by the algorithm does not increase relative to the size of the input array. It uses the same amount of memory and create the same amount of variables regardless of the size of the input, making this algorithm quite space efficient. The space efficiency mostly comes from the fact that it mutates the input array in-place. This is known as a <strong>destructive sort</strong> because it “destroys” the positions of the values in the array.</p>
<h2 id="when-should-you-use-bubble-sort">When should you use Bubble Sort?</h2>
<p>Nearly never, but it may be a good choice in the following list of special cases:</p>
<ul>
<li>When sorting really small arrays where run time will be negligible no matter what algorithm you choose.</li>
<li>When sorting arrays that you expect to already be nearly sorted.</li>
<li>At parties</li>
</ul>
<hr />
<h1 id="selection-sort-analysis">Selection Sort Analysis</h1>
<p>Since a component of Selection Sort requires us to locate the smallest value in the array, let’s focus on that pattern in isolation:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">function</span> <span class="at">minumumValueIndex</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="kw">let</span> minIndex <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-5" title="5">        <span class="cf">if</span> (arr[minIndex] <span class="op">&gt;</span> arr[j]) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-6" title="6">            minIndex <span class="op">=</span> j<span class="op">;</span></a>
<a class="sourceLine" id="cb16-7" title="7">        <span class="op">}</span></a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10">    <span class="cf">return</span> minIndex<span class="op">;</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>Pretty basic code right? We won’t use this explicit helper function to solve selection sort, however we will borrow from this pattern soon.</p>
<h2 id="selection-sort-js-implementation">Selection Sort JS Implementation</h2>
<p>We’ll also utilize the classic swap pattern that we introduced in the bubble sort. To refresh:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">function</span> <span class="at">swap</span>(arr<span class="op">,</span> index1<span class="op">,</span> index2) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="kw">let</span> temp <span class="op">=</span> arr[index1]<span class="op">;</span></a>
<a class="sourceLine" id="cb17-3" title="3">  arr[index1] <span class="op">=</span> arr[index2]<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4">  arr[index2] <span class="op">=</span> temp<span class="op">;</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>Now for the punchline! Take a look at the snippet below and try to understand how it corresponds to our conceptual understanding of the selection sort algorithm. Scroll down to the commented version when you get stuck.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">function</span> <span class="at">selectionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">let</span> minIndex <span class="op">=</span> i<span class="op">;</span></a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-6" title="6">      <span class="cf">if</span> (arr[minIndex] <span class="op">&gt;</span> arr[j]) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-7" title="7">        minIndex <span class="op">=</span> j<span class="op">;</span></a>
<a class="sourceLine" id="cb18-8" title="8">      <span class="op">}</span></a>
<a class="sourceLine" id="cb18-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11">    <span class="at">swap</span>(arr<span class="op">,</span> i<span class="op">,</span> minIndex)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb18-13" title="13">  <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb18-14" title="14"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// commented</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">function</span> <span class="at">selectionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="co">// the `i` loop will track the index that points to the first element of the unsorted region:</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="co">//    this means that the sorted region is everything left of index i</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="co">//    and the unsorted region is everything to the right of index i</span></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-7" title="7">        <span class="kw">let</span> minIndex <span class="op">=</span> i<span class="op">;</span></a>
<a class="sourceLine" id="cb19-8" title="8"></a>
<a class="sourceLine" id="cb19-9" title="9">        <span class="co">// the `j` loop will iterate through the unsorted region and find the index of the smallest element</span></a>
<a class="sourceLine" id="cb19-10" title="10">        <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-11" title="11">            <span class="cf">if</span> (arr[minIndex] <span class="op">&gt;</span> arr[j]) <span class="op">{</span></a>
<a class="sourceLine" id="cb19-12" title="12">                minIndex <span class="op">=</span> j<span class="op">;</span></a>
<a class="sourceLine" id="cb19-13" title="13">            <span class="op">}</span></a>
<a class="sourceLine" id="cb19-14" title="14">        <span class="op">}</span></a>
<a class="sourceLine" id="cb19-15" title="15"></a>
<a class="sourceLine" id="cb19-16" title="16">        <span class="co">// after we find the minIndex in the unsorted region,</span></a>
<a class="sourceLine" id="cb19-17" title="17">        <span class="co">// swap that minIndex with the first index of the unsorted region</span></a>
<a class="sourceLine" id="cb19-18" title="18">        <span class="at">swap</span>(arr<span class="op">,</span> i<span class="op">,</span> minIndex)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-19" title="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb19-20" title="20">    <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb19-21" title="21"><span class="op">}</span></a></code></pre></div>
<h2 id="time-complexity-analysis">Time Complexity Analysis</h2>
<p>Selection Sort runtime is O(n<sup>2</sup>) because:</p>
<ul>
<li><code>n</code> is the length of the input array</li>
<li>The outer loop i contributes O(n) in isolation, this is plain to see</li>
<li>The inner loop j is more complicated, it will make one less iteration for every iteration of i.
<ul>
<li>for example, let’s say we have an array of 10 elements, <code>n = 10</code>.</li>
<li>the first full cycle of <code>j</code> will have 9 iterations</li>
<li>the second full cycle of <code>j</code> will have 8 iterations</li>
<li>the third full cycle of <code>j</code> will have 7 iterations</li>
<li>…</li>
<li>the last full cycle of <code>j</code> will have 1 iteration</li>
<li>This means that the inner loop j will contribute roughly O(n / 2) on average</li>
</ul></li>
<li>The two loops are nested so our total time complexity is O(n * n / 2) = O(n<sup>2</sup>)</li>
</ul>
<p>You’ll notice that during this analysis we said something silly like O(n / 2). In some analyses such as this one, we’ll prefer to drop the constants only at the end of the sketch so you understand the logical steps we took to derive a complicated time complexity.</p>
<h2 id="space-complexity-analysis-o1">Space Complexity Analysis: O(1)</h2>
<p>The amount of memory consumed by the algorithm does not increase relative to the size of the input array. We use the same amount of memory and create the same amount of variables regardless of the size of our input. A quick indicator of this is the fact that we don’t create any arrays.</p>
<h2 id="when-should-we-use-selection-sort">When should we use Selection Sort?</h2>
<p>There is really only one use case where Selection Sort becomes superior to Bubble Sort. Both algorithms are quadratic in time and constant in space, but the point at which they differ is in the <em>number of swaps</em> they make.</p>
<p>Bubble Sort, in the worst case, invokes a swap on every single comparison. Selection Sort only swaps once our inner loop has completely finished traversing the array. Therefore, Selection Sort is optimized to make the least possible number of swaps.</p>
<p>Selection Sort becomes advantageous when making a swap is the most expensive operation in your system. You will likely rarely encounter this scenario, but in a situation where you’ve built (or have inherited) a system with suboptimal write speed ability, for instance, maybe you’re sorting data in a specialized database tuned strictly for fast read speeds at the expense of slow write speeds, using Selection Sort would save you a ton of expensive operations that could potential crash your system under peak load.</p>
<p>Though in industry this situation is very rare, the insights above make for a fantastic conversational piece when weighing technical tradeoffs while strategizing solutions in an interview setting. This commentary may help deliver the impression that you are well-versed in system design and technical analysis, a key indicator that someone is prepared for a senior level position.</p>
<hr />
<h1 id="insertion-sort-analysis">Insertion Sort Analysis</h1>
<p>Take a look at the snippet below and try to understand how it corresponds to our conceptual understanding of the Insertion Sort algorithm. Scroll down to the commented version when you get stuck:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">function</span> <span class="at">insertionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="kw">let</span> currElement <span class="op">=</span> arr[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb20-4" title="4">    <span class="cf">for</span> (<span class="kw">var</span> j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> currElement <span class="op">&lt;</span> arr[j]<span class="op">;</span> j<span class="op">--</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb20-5" title="5">      arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j]<span class="op">;</span></a>
<a class="sourceLine" id="cb20-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb20-7" title="7">    arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> currElement<span class="op">;</span></a>
<a class="sourceLine" id="cb20-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb20-9" title="9">  <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">function</span> <span class="at">insertionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="co">// the `i` loop will iterate through every element of the array</span></a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="co">// we begin at i = 1, because we can consider the first element of the array as a</span></a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="co">// trivially sorted region of only one element</span></a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="co">// insertion sort allows us to insert new elements anywhere within the sorted region</span></a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb21-7" title="7">        <span class="co">// grab the first element of the unsorted region</span></a>
<a class="sourceLine" id="cb21-8" title="8">        <span class="kw">let</span> currElement <span class="op">=</span> arr[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb21-9" title="9"></a>
<a class="sourceLine" id="cb21-10" title="10">        <span class="co">// the `j` loop will iterate left through the sorted region,</span></a>
<a class="sourceLine" id="cb21-11" title="11">        <span class="co">// looking for a legal spot to insert currElement</span></a>
<a class="sourceLine" id="cb21-12" title="12">        <span class="cf">for</span> (<span class="kw">var</span> j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> currElement <span class="op">&lt;</span> arr[j]<span class="op">;</span> j<span class="op">--</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb21-13" title="13">            <span class="co">// keep moving left while currElement is less than the j-th element</span></a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15">            arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j]<span class="op">;</span></a>
<a class="sourceLine" id="cb21-16" title="16">            <span class="co">// the line above will move the j-th element to the right,</span></a>
<a class="sourceLine" id="cb21-17" title="17">            <span class="co">// leaving a gap to potentially insert currElement</span></a>
<a class="sourceLine" id="cb21-18" title="18">        <span class="op">}</span></a>
<a class="sourceLine" id="cb21-19" title="19">        <span class="co">// insert currElement into that gap</span></a>
<a class="sourceLine" id="cb21-20" title="20">        arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> currElement<span class="op">;</span></a>
<a class="sourceLine" id="cb21-21" title="21">    <span class="op">}</span></a>
<a class="sourceLine" id="cb21-22" title="22">    <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb21-23" title="23"><span class="op">}</span></a></code></pre></div>
<p>There are a few key pieces to point out in the above solution before moving forward:</p>
<ol type="1">
<li><p>The outer <code>for</code> loop starts at the 1st index, not the 0th index, and moves to the right.</p></li>
<li><p>The inner <code>for</code> loop starts immediately to the left of the current element, and moves to the left.</p></li>
<li>The condition for the inner <code>for</code> loop is complicated, and behaves similarly to a while loop!
<ul>
<li>It continues iterating to the left toward <code>j = 0</code>, <em>only while</em> the <code>currElement</code> is less than <code>arr[j]</code>.</li>
<li>It does this over and over until it finds the proper place to insert <code>currElement</code>, and then we exit the inner loop!</li>
</ul></li>
<li><p>When shifting elements in the sorted region to the right, it <em>does not</em> replace the value at their old index! If the input array is <code>[1, 2, 4, 3]</code>, and <code>currElement</code> is <code>3</code>, after comparing <code>4</code> and <code>3</code>, but before inserting <code>3</code> between <code>2</code> and <code>4</code>, the array will look like this: <code>[1, 2, 4, 4]</code>.</p></li>
</ol>
<p>If you are currently scratching your head, that is perfectly okay because when this one clicks, it clicks for good.</p>
<p>If you’re struggling, you should try taking out a pen and paper and step through the solution provided above one step at a time. Keep track of <code>i</code>, <code>j</code>, <code>currElement</code>, <code>arr[j]</code>, and the input <code>arr</code> itself <em>at every step</em>. After going through this a few times, you’ll have your “ah HA!” moment.</p>
<h2 id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h2>
<p>Insertion Sort runtime is O(n<sup>2</sup>) because:</p>
<p>In the <strong>worst case scenario</strong> where our input array is entirely unsorted, since this algorithm contains a nested loop, its run time behaves similarly to <code>bubbleSort</code> and <code>selectionSort</code>. In this case, we are forced to make a comparison at each iteration of the inner loop. Not convinced? Let’s derive the complexity. We’ll use much of the same argument as we did in <code>selectionSort</code>. Say we had the worst case scenario where are input array is sorted in full decreasing order, but we wanted to sort it in increasing order:</p>
<ul>
<li><code>n</code> is the length of the input array</li>
<li>The outer loop i contributes O(n) in isolation, this is plain to see</li>
<li>The inner loop j is more complicated. We know j will iterate until it finds an appropriate place to insert the <code>currElement</code> into the sorted region. However, since we are discussing the case where the data is already in decreasing order, the element must travel the maximum distance to find it’s insertion point! We know this insertion point to be index 0, since every <code>currElement</code> will be the next smallest of the array. So:
<ul>
<li>the 1st element travels 1 distance to be inserted</li>
<li>the 2nd element travels 2 distance to be inserted</li>
<li>the 3rd element travels 3 distance to be inserted</li>
<li>…</li>
<li>the n-1th element travels n-1 distance to be inserted</li>
<li>This means that our inner loop j will contribute roughly O(n / 2) on average</li>
</ul></li>
<li>The two loops are nested so our total time complexity is O(n * n / 2) = O(n<sup>2</sup>)</li>
</ul>
<h3 id="space-complexity-o1-1">Space Complexity: O(1)</h3>
<p>The amount of memory consumed by the algorithm does not increase relative to the size of the input array. We use the same amount of memory and create the same amount of variables regardless of the size of our input. A quick indicator of this is the fact that we don’t create any arrays.</p>
<h2 id="when-should-you-use-insertion-sort">When should you use Insertion Sort?</h2>
<p>Insertion Sort has one advantage that makes it absolutely supreme in one special case. Insertion Sort is what’s known as an “online” algorithm. Online algorithms are great when you’re dealing with <em>streaming data</em>, because they can sort the data live <em>as it is received</em>.</p>
<p>If you must sort a set of data that is ever-incoming, for example, maybe you are sorting the most relevant posts in a social media feed so that those posts that are most likely to impact the site’s audience always appear at the top of the feed, an online algorithm like Insertion Sort is a great option.</p>
<p>Insertion Sort works well in this situation because the left side of the array is always sorted, and in the case of nearly sorted arrays, it can run in linear time. The absolute best case scenario for Insertion Sort is when there is only one unsorted element, and it is located all the way to the right of the array.</p>
<p>Well, if you have data constantly being pushed to the array, it will always be added to the right side. If you keep your algorithm constantly running, the left side will always be sorted. Now you have linear time sort.</p>
<p>Otherwise, Insertion Sort is, in general, useful in all the same situations as Bubble Sort. It’s a good option when:</p>
<ul>
<li>You are sorting really small arrays where run time will be negligible no matter what algorithm we choose.</li>
<li>You are sorting an array that you expect to already be nearly sorted.</li>
</ul>
<hr />
<h1 id="merge-sort-analysis">Merge Sort Analysis</h1>
<p>You needed to come up with two pieces of code to make merge sort work.</p>
<h2 id="full-code">Full code</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">function</span> <span class="at">merge</span>(array1<span class="op">,</span> array2) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="kw">let</span> merged <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">  <span class="cf">while</span> (<span class="va">array1</span>.<span class="at">length</span> <span class="op">||</span> <span class="va">array2</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-5" title="5">    <span class="kw">let</span> ele1 <span class="op">=</span> <span class="va">array1</span>.<span class="at">length</span> <span class="op">?</span> array1[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="kw">let</span> ele2 <span class="op">=</span> <span class="va">array2</span>.<span class="at">length</span> <span class="op">?</span> array2[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb22-7" title="7"></a>
<a class="sourceLine" id="cb22-8" title="8">    <span class="kw">let</span> next<span class="op">;</span></a>
<a class="sourceLine" id="cb22-9" title="9">    <span class="cf">if</span> (ele1 <span class="op">&lt;</span> ele2) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-10" title="10">      next <span class="op">=</span> <span class="va">array1</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb22-11" title="11">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-12" title="12">      next <span class="op">=</span> <span class="va">array2</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb22-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb22-14" title="14"></a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="va">merged</span>.<span class="at">push</span>(next)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb22-17" title="17"></a>
<a class="sourceLine" id="cb22-18" title="18">  <span class="cf">return</span> merged<span class="op">;</span></a>
<a class="sourceLine" id="cb22-19" title="19"><span class="op">}</span></a>
<a class="sourceLine" id="cb22-20" title="20"></a>
<a class="sourceLine" id="cb22-21" title="21"><span class="kw">function</span> <span class="at">mergeSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-22" title="22">  <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-23" title="23">    <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb22-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb22-25" title="25"></a>
<a class="sourceLine" id="cb22-26" title="26">  <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-27" title="27">  <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-28" title="28">  <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-29" title="29"></a>
<a class="sourceLine" id="cb22-30" title="30">  <span class="kw">let</span> sortedLeft <span class="op">=</span> <span class="at">mergeSort</span>(leftHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-31" title="31">  <span class="kw">let</span> sortedRight <span class="op">=</span> <span class="at">mergeSort</span>(rightHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-32" title="32"></a>
<a class="sourceLine" id="cb22-33" title="33">  <span class="cf">return</span> <span class="at">merge</span>(sortedLeft<span class="op">,</span> sortedRight)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-34" title="34"><span class="op">}</span></a></code></pre></div>
<h2 id="merging-two-sorted-arrays">Merging two sorted arrays</h2>
<p>Merging two sorted arrays is simple. Since both arrays are sorted, we know the smallest numbers to always be at the front of the arrays. We can construct the new array by comparing the first elements of both input arrays. We remove the smaller element from it’s respective array and add it to our new array. Do this until both input arrays are empty:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">function</span> <span class="at">merge</span>(array1<span class="op">,</span> array2) <span class="op">{</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="kw">let</span> merged <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4">  <span class="cf">while</span> (<span class="va">array1</span>.<span class="at">length</span> <span class="op">||</span> <span class="va">array2</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb23-5" title="5">    <span class="kw">let</span> ele1 <span class="op">=</span> <span class="va">array1</span>.<span class="at">length</span> <span class="op">?</span> array1[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="kw">let</span> ele2 <span class="op">=</span> <span class="va">array2</span>.<span class="at">length</span> <span class="op">?</span> array2[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8">    <span class="kw">let</span> next<span class="op">;</span></a>
<a class="sourceLine" id="cb23-9" title="9">    <span class="cf">if</span> (ele1 <span class="op">&lt;</span> ele2) <span class="op">{</span></a>
<a class="sourceLine" id="cb23-10" title="10">      next <span class="op">=</span> <span class="va">array1</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb23-11" title="11">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-12" title="12">      next <span class="op">=</span> <span class="va">array2</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb23-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb23-14" title="14"></a>
<a class="sourceLine" id="cb23-15" title="15">    <span class="va">merged</span>.<span class="at">push</span>(next)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb23-17" title="17"></a>
<a class="sourceLine" id="cb23-18" title="18">  <span class="cf">return</span> merged<span class="op">;</span></a>
<a class="sourceLine" id="cb23-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>Remember the following about JavaScript to understand the above code.</p>
<ul>
<li><code>0</code> is considered a falsey value, meaning it acts like <code>false</code> when used in Boolean expressions. All other numbers are truthy.</li>
<li><code>Infinity</code> is a value that is guaranteed to be greater than any other quantity</li>
<li><code>shift</code> is an array method that removes and returns the first element</li>
</ul>
<p>Here’s the annotated version.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="co">// commented</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">function</span> <span class="at">merge</span>(array1<span class="op">,</span> array2) <span class="op">{</span></a>
<a class="sourceLine" id="cb24-3" title="3">  <span class="kw">let</span> merged <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="co">// keep running while either array still contains elements</span></a>
<a class="sourceLine" id="cb24-6" title="6">  <span class="cf">while</span> (<span class="va">array1</span>.<span class="at">length</span> <span class="op">||</span> <span class="va">array2</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="co">// if array1 is nonempty, take its the first element as ele1</span></a>
<a class="sourceLine" id="cb24-8" title="8">    <span class="co">// otherwise array1 is empty, so take Infinity as ele1</span></a>
<a class="sourceLine" id="cb24-9" title="9">    <span class="kw">let</span> ele1 <span class="op">=</span> <span class="va">array1</span>.<span class="at">length</span> <span class="op">?</span> array1[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb24-10" title="10"></a>
<a class="sourceLine" id="cb24-11" title="11">    <span class="co">// do the same for array2, ele2</span></a>
<a class="sourceLine" id="cb24-12" title="12">    <span class="kw">let</span> ele2 <span class="op">=</span> <span class="va">array2</span>.<span class="at">length</span> <span class="op">?</span> array2[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14">    <span class="kw">let</span> next<span class="op">;</span></a>
<a class="sourceLine" id="cb24-15" title="15">    <span class="co">// remove the smaller of the eles from it&#39;s array</span></a>
<a class="sourceLine" id="cb24-16" title="16">    <span class="cf">if</span> (ele1 <span class="op">&lt;</span> ele2) <span class="op">{</span></a>
<a class="sourceLine" id="cb24-17" title="17">      next <span class="op">=</span> <span class="va">array1</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb24-18" title="18">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb24-19" title="19">      next <span class="op">=</span> <span class="va">array2</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb24-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb24-21" title="21"></a>
<a class="sourceLine" id="cb24-22" title="22">    <span class="co">// and add that ele to the new array</span></a>
<a class="sourceLine" id="cb24-23" title="23">    <span class="va">merged</span>.<span class="at">push</span>(next)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb24-25" title="25"></a>
<a class="sourceLine" id="cb24-26" title="26">  <span class="cf">return</span> merged<span class="op">;</span></a>
<a class="sourceLine" id="cb24-27" title="27"><span class="op">}</span></a></code></pre></div>
<p>By using <code>Infinity</code> as the default element when an array is empty, we are able to elegantly handle the scenario where one array empties before the other. We know that any actual element will be less than <code>Infinity</code> so we will continually take the other element into our merged array.</p>
<p>In other words, we can safely handle this edge case:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="at">merge</span>([<span class="dv">10</span><span class="op">,</span> <span class="dv">13</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">25</span>]<span class="op">,</span> [])<span class="op">;</span>  <span class="co">// =&gt; [10, 13, 15, 25]</span></a></code></pre></div>
<p>Nice! We now have a way to merge two sorted arrays into a single sorted array. It’s worth mentioning that <code>merge</code> will have a <code>O(n)</code> runtime where <code>n</code> is the combined length of the two input arrays. This is what we meant when we said it was “easy” to merge two sorted arrays; linear time is fast! We’ll find fact this useful later.</p>
<h2 id="divide-and-conquer-step-by-step">Divide and conquer, step-by-step</h2>
<p>Now that we satisfied the merge idea, let’s handle the second point. That is, we say an array of 1 or 0 elements is already sorted. This will be the base case of our recursion. Let’s begin adding this code:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">function</span> <span class="at">mergeSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb26-5" title="5">    <span class="co">// ....</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>If our base case pertains to an array of a very small size, then the design of our recursive case should make progress toward hitting this base scenario. In other words, we should recursively call <code>mergeSort</code> on smaller and smaller arrays. A logical way to do this is to take the input array and split it into left and right halves.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">function</span> <span class="at">mergeSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb27-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb27-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb27-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb27-5" title="5"></a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-9" title="9"></a>
<a class="sourceLine" id="cb27-10" title="10">    <span class="kw">let</span> sortedLeft <span class="op">=</span> <span class="at">mergeSort</span>(leftHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-11" title="11">    <span class="kw">let</span> sortedRight <span class="op">=</span> <span class="at">mergeSort</span>(rightHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb27-12" title="12">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb27-13" title="13"><span class="op">}</span></a></code></pre></div>
<p>Here is the part of the recursion where we do a lot of hand waving and we take things on faith. We know that <code>mergeSort</code> will take in an array and return the sorted version; we assume that it works. That means the two recursive calls will return the <code>sortedLeft</code> and <code>sortedRight</code> halves.</p>
<p>Okay, so we have two sorted arrays. We want to return one sorted array. So <code>merge</code> them! Using the <code>merge</code> function we designed earlier:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">function</span> <span class="at">mergeSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb28-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb28-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb28-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb28-5" title="5"></a>
<a class="sourceLine" id="cb28-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10">    <span class="kw">let</span> sortedLeft <span class="op">=</span> <span class="at">mergeSort</span>(leftHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-11" title="11">    <span class="kw">let</span> sortedRight <span class="op">=</span> <span class="at">mergeSort</span>(rightHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-12" title="12"></a>
<a class="sourceLine" id="cb28-13" title="13">    <span class="cf">return</span> <span class="at">merge</span>(sortedLeft<span class="op">,</span> sortedRight)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-14" title="14"><span class="op">}</span></a></code></pre></div>
<p>Wow. that’s it. Notice how light the implementation of <code>mergeSort</code> is. Much of the heavy lifting (the actually comparisons) is done by the <code>merge</code> helper.</p>
<p><code>mergeSort</code> is a classic example of a “Divide and Conquer” algorithm. In other words, we keep breaking the array into smaller and smaller sub arrays. This is the same as saying we take the problem and break it down into smaller and smaller subproblems. We do this until the subproblems are so small that we trivially know the answer to them (an array length 0 or 1 is already sorted). Once we have those subanswers we can combine to reconstruct the larger problems that we previously divided (merge the left and right subarrays).</p>
<h2 id="time-and-space-complexity-analysis-1">Time and Space Complexity Analysis</h2>
<h3 id="time-complexity-on-logn">Time Complexity: O(n log(n))</h3>
<ul>
<li><code>n</code> is the length of the input array</li>
<li>We must calculate how many recursive calls we make. The number of recursive calls is the number of times we must split the array to reach the base case. Since we split in half each time, the number of recursive calls is <code>O(log(n))</code>.
<ul>
<li>for example, say we had an array of length <code>32</code></li>
<li>then the length would change as <code>32 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</code>, we have to split 5 times before reaching the base case, <code>log(32) = 5</code></li>
<li>in our algorithm, <strong>log(n)</strong> describes how many times we must halve <strong>n</strong> until the quantity reaches 1.</li>
</ul></li>
<li>Besides the recursive calls, we must consider the while loop within the <code>merge</code> function, which contributes <code>O(n)</code> in isolation</li>
<li>We call <code>merge</code> in every recursive <code>mergeSort</code> call, so the total complexity is <strong>O(n * log(n))</strong></li>
</ul>
<h3 id="space-complexity-on">Space Complexity: O(n)</h3>
<p>Merge Sort is the first non-O(1) space sorting algorithm we’ve seen thus far.</p>
<p>The larger the size of our input array, the greater the number of subarrays we must create in memory. These are not free! They each take up finite space, and we will need a new subarray for each element in the original input. Therefore, Merge Sort has a linear space complexity, O(n).</p>
<h3 id="when-should-you-use-merge-sort">When should you use Merge Sort?</h3>
<p>Unless we, the engineers, have access in advance to some unique, exploitable insight about our dataset, it turns out that O(n log n) time is <em>the best</em> we can do when sorting unknown datasets.</p>
<p>That means that Merge Sort is fast! It’s way faster than Bubble Sort, Selection Sort, and Insertion Sort. However, due to its linear space complexity, we must always weigh the trade off between speed and memory consumption when making the choice to use Merge Sort. Consider the following:</p>
<ul>
<li>If you have unlimited memory available, use it, it’s fast!</li>
<li>If you have a decent amount of memory available and a medium sized dataset, run some tests first, but use it!</li>
<li>In other cases, maybe you should consider other options.</li>
</ul>
<hr />
<h1 id="quick-sort-1">Quick Sort</h1>
<p>Let’s begin structuring the recursion. The base case of any recursive problem is where the input is so trivial, we immediately know the answer without calculation. If our problem is to sort an array, what is the trivial array? An array of 1 or 0 elements! Let’s establish the code:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb29-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb29-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb29-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>If our base case pertains to an array of a very small size, then the design of our recursive case should make progress toward hitting this base scenario. In other words, we should recursively call <code>quickSort</code> on smaller and smaller arrays. This is very similar to our previous <code>mergeSort</code>, except we don’t just split the array down the middle. Instead we should arbitrarily choose an element of the array as a pivot and partition the remaining elements relative to this pivot:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb30-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb30-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb30-5" title="5"></a>
<a class="sourceLine" id="cb30-6" title="6">    <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb30-7" title="7">    <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-8" title="8">    <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-9" title="9">    <span class="co">// ...</span></a></code></pre></div>
<p>Here is what to notice about the partition step above: 1. the pivot is an element of the array; we arbitrarily chose the first element 2. we removed the pivot from the master array before we filter into the left and right partitions</p>
<p>Now that we have the two subarrays of <code>left</code> and <code>right</code> we have our subproblems! To solve these subproblems we must sort the subarrays. I wish we had a function that sorts an array…oh wait we do, <code>quickSort</code>! Recursively:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb31-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb31-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb31-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb31-5" title="5"></a>
<a class="sourceLine" id="cb31-6" title="6">    <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb31-7" title="7">    <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-8" title="8">    <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-9" title="9"></a>
<a class="sourceLine" id="cb31-10" title="10">    <span class="kw">let</span> leftSorted <span class="op">=</span> <span class="at">quickSort</span>(left)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-11" title="11">    <span class="kw">let</span> rightSorted <span class="op">=</span> <span class="at">quickSort</span>(right)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-12" title="12">    <span class="co">// ...</span></a></code></pre></div>
<p>Okay, so we have the two sorted partitions. This means we have the two subsolutions. But how do we put them together? Think about how we partitioned them in the first place. Everything in <code>leftSorted</code> is <strong>guaranteed</strong> to be less than everything in <code>rightSorted</code>. On top of that, <code>pivot</code> should be placed after the last element in <code>leftSorted</code>, but before the first element in <code>rightSorted</code>. So all we need to do is to combine the elements in the order “left, pivot, right”!</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb32-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb32-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb32-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb32-5" title="5"></a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb32-7" title="7">    <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-8" title="8">    <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-9" title="9"></a>
<a class="sourceLine" id="cb32-10" title="10">    <span class="kw">let</span> leftSorted <span class="op">=</span> <span class="at">quickSort</span>(left)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-11" title="11">    <span class="kw">let</span> rightSorted <span class="op">=</span> <span class="at">quickSort</span>(right)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-12" title="12"></a>
<a class="sourceLine" id="cb32-13" title="13">    <span class="cf">return</span> <span class="va">leftSorted</span>.<span class="at">concat</span>([pivot]).<span class="at">concat</span>(rightSorted)<span class="op">;</span></a>
<a class="sourceLine" id="cb32-14" title="14"><span class="op">}</span></a></code></pre></div>
<p>That last <code>concat</code> line is a bit clunky. Bonus JS Lesson: we can use the spread <code>...</code> operator to elegantly concatenate arrays. In general:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">let</span> one <span class="op">=</span> [<span class="st">&#39;a&#39;</span><span class="op">,</span> <span class="st">&#39;b&#39;</span>]</a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">let</span> two <span class="op">=</span> [<span class="st">&#39;d&#39;</span><span class="op">,</span> <span class="st">&#39;e&#39;</span><span class="op">,</span> <span class="st">&#39;f&#39;</span>]</a>
<a class="sourceLine" id="cb33-3" title="3"><span class="kw">let</span> newArr <span class="op">=</span> [ ...<span class="at">one</span><span class="op">,</span> <span class="st">&#39;c&#39;</span><span class="op">,</span> ...<span class="at">two</span>  ]<span class="op">;</span></a>
<a class="sourceLine" id="cb33-4" title="4">newArr<span class="op">;</span> <span class="co">// =&gt;  [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]</span></a></code></pre></div>
<p>Utilizing that spread pattern gives us this final implementation:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb34-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb34-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb34-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb34-5" title="5"></a>
<a class="sourceLine" id="cb34-6" title="6">    <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb34-7" title="7">    <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-8" title="8">    <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-9" title="9"></a>
<a class="sourceLine" id="cb34-10" title="10">    <span class="kw">let</span> leftSorted <span class="op">=</span> <span class="at">quickSort</span>(left)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-11" title="11">    <span class="kw">let</span> rightSorted <span class="op">=</span> <span class="at">quickSort</span>(right)<span class="op">;</span></a>
<a class="sourceLine" id="cb34-12" title="12"></a>
<a class="sourceLine" id="cb34-13" title="13">    <span class="cf">return</span> [ ...<span class="at">leftSorted</span><span class="op">,</span> pivot<span class="op">,</span> ...<span class="at">rightSorted</span> ]<span class="op">;</span></a>
<a class="sourceLine" id="cb34-14" title="14"><span class="op">}</span></a></code></pre></div>
<h3 id="quicksort-sort-js-implementation">Quicksort Sort JS Implementation</h3>
<p>That code was so clean we should show it again. Here’s the complete code for your reference, for when you <code>ctrl+F "quicksort"</code> the night before an interview:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-3" title="3">        <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb35-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6">    <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb35-7" title="7">    <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-9" title="9"></a>
<a class="sourceLine" id="cb35-10" title="10">    <span class="kw">let</span> leftSorted <span class="op">=</span> <span class="at">quickSort</span>(left)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-11" title="11">    <span class="kw">let</span> rightSorted <span class="op">=</span> <span class="at">quickSort</span>(right)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-12" title="12"></a>
<a class="sourceLine" id="cb35-13" title="13">    <span class="cf">return</span> [ ...<span class="at">leftSorted</span><span class="op">,</span> pivot<span class="op">,</span> ...<span class="at">rightSorted</span> ]<span class="op">;</span></a>
<a class="sourceLine" id="cb35-14" title="14"><span class="op">}</span></a></code></pre></div>
<h2 id="time-and-space-complexity-analysis-2">Time and Space Complexity Analysis</h2>
<p>Here is a summary of the complexity.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li>Avg Case: O(n log(n))</li>
<li>Worst Case: O(n<sup>2</sup>)</li>
</ul>
<p>The runtime analysis of <code>quickSort</code> is more complex than <code>mergeSort</code></p>
<ul>
<li><code>n</code> is the length of the input array</li>
<li>The partition step alone is <code>O(n)</code></li>
<li>We must calculate how many recursive calls we make. The number of recursive calls is the number of times we must split the array to reach the base case. This is dependent on how we choose the pivot. Let’s analyze the best and worst case:
<ul>
<li><strong>Best Case:</strong> We are lucky and always choose the median as the pivot. This means the left and right partitions will have equal length. This will halve the array length at every step of the recursion. We benefit from this halving with <code>O(log(n))</code> recursive calls to reach the base case.</li>
<li><strong>Worst Case:</strong> We are unlucky and always choose the min or max as the pivot. This means one partition will contain everything, and the other partition is empty. This will decrease the array length by 1 at every step of the recursion. We suffer from <code>O(n)</code> recursive calls to reach the base case.</li>
</ul></li>
<li>The partition step occurs in every recursive call, so our total complexities are:
<ul>
<li><strong>Best Case:</strong> O(n * log(n))</li>
<li><strong>Worst Case:</strong> O(n<sup>2</sup>)</li>
</ul></li>
</ul>
<p>Although we typically take the worst case when describing Big-O for an algorithm, much research on <code>quickSort</code> has shown the worst case to be an exceedingly rare occurrence even if we choose the pivot at random. Because of this we still consider <code>quickSort</code> an efficient algorithm. This is a common interview talking point, so you should be familiar with the relationship between the choice of pivot and efficiency of the algorithm.</p>
<p>Just in case: A somewhat common question a student may ask when studying <code>quickSort</code> is, “If the median is the best pivot, why don’t we always just choose the median when we partition?” Don’t overthink this. To know the median of an array, it must be sorted in the first place.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>Our implementation of <code>quickSort</code> uses <code>O(n)</code> space because of the partition arrays we create. There is an in-place version of <code>quickSort</code> that uses <code>O(log(n))</code> space. <code>O(log(n))</code> space is not huge benefit over <code>O(n)</code>. You’ll also find our version of <code>quickSort</code> as easier to remember, easier to implement. Just know that a <code>O(logn)</code> space <code>quickSort</code> exists.</p>
<h3 id="when-should-you-use-quick-sort">When should you use Quick Sort?</h3>
<ul>
<li>When you are in a pinch and need to throw down an efficient sort (on average). The recursive code is light and simple to implement; much smaller than <code>mergeSort</code>.</li>
<li>When constant space is important to you, use the in-place version. This will of course trade off some simplicity of implementation.</li>
</ul>
<p>If you know some constraints about dataset you can make some modifications to optimize pivot choice. Here’s some food for thought. Our implementation of <code>quickSort</code> will always take the first element as the pivot. This means we will suffer from the worst case time complexity in the event that we are given an already sorted array (ironic isn’t it?). If you know your input data to be mostly already sorted, randomize the choice of pivot - this is a very easy change. Bam. Solved like a true engineer.</p>
<hr />
<h1 id="binary-search-1">Binary Search</h1>
<p>We’ll implement binary search recursively. As always, we start with a base case that captures the scenario of the input array being so trivial, that we know the answer without further calculation. If we are given an empty array and a target, we can be certain that the target is not inside of the array:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb36-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb36-3" title="3">        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb36-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb36-5" title="5">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>Now for our recursive case. If we want to get a time complexity less than <code>O(n)</code>, we must avoid touching all <code>n</code> elements. Adopting our dictionary strategy, let’s find the middle element and grab references to the left and right halves of the sorted array:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb37-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb37-3" title="3">        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb37-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb37-5" title="5"></a>
<a class="sourceLine" id="cb37-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-9" title="9">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>It’s worth pointing out that the left and right halves do not contain the middle element we chose.</p>
<p>Here is where we leverage the sorted property of the array. If the target is less than the middle, then the target must be in the left half of the array. If the target is greater than the middle, then the target must be in the right half of the array. So we can narrow our search to one of these halves, and ignore the other. Luckily we have a function that can search the half, its <code>binarySearch</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb38-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb38-3" title="3">        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb38-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb38-5" title="5"></a>
<a class="sourceLine" id="cb38-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-9" title="9"></a>
<a class="sourceLine" id="cb38-10" title="10">    <span class="cf">if</span> (target <span class="op">&lt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb38-11" title="11">        <span class="cf">return</span> <span class="at">binarySearch</span>(leftHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-12" title="12">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (target <span class="op">&gt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb38-13" title="13">        <span class="cf">return</span> <span class="at">binarySearch</span>(rightHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb38-15" title="15">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb38-16" title="16"><span class="op">}</span></a></code></pre></div>
<p>We know <code>binarySeach</code> will return the correct Boolean, so we just pass that result up by returning it ourselves. However, something is lacking in our code. It is only possible to get a false from the literal <code>return false</code> line, but there is no <code>return true</code>. Looking at our conditionals, we handle the cases where the target is less than middle or the target is greater than the middle, but what if the product is <strong>equal</strong> to the middle? If the target is equal to the middle, then we found the target and should <code>return true</code>! This is easy to add with an <code>else</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-3" title="3">        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb39-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb39-5" title="5"></a>
<a class="sourceLine" id="cb39-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-9" title="9"></a>
<a class="sourceLine" id="cb39-10" title="10">    <span class="cf">if</span> (target <span class="op">&lt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-11" title="11">        <span class="cf">return</span> <span class="at">binarySearch</span>(leftHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-12" title="12">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (target <span class="op">&gt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-13" title="13">        <span class="cf">return</span> <span class="at">binarySearch</span>(rightHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-14" title="14">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-15" title="15">        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb39-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb39-17" title="17"><span class="op">}</span></a></code></pre></div>
<p>To wrap up, we have confidence of our base case will eventually be hit because we are continually halving the array. We halve the array until it’s length is 0 or we actually find the target.</p>
<h3 id="binary-search-js-implementation">Binary Search JS Implementation</h3>
<p>Here is the code again for your quick reference:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-2" title="2">    <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-3" title="3">        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb40-4" title="4">    <span class="op">}</span></a>
<a class="sourceLine" id="cb40-5" title="5"></a>
<a class="sourceLine" id="cb40-6" title="6">    <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-7" title="7">    <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-8" title="8">    <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-9" title="9"></a>
<a class="sourceLine" id="cb40-10" title="10">    <span class="cf">if</span> (target <span class="op">&lt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-11" title="11">        <span class="cf">return</span> <span class="at">binarySearch</span>(leftHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-12" title="12">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (target <span class="op">&gt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-13" title="13">        <span class="cf">return</span> <span class="at">binarySearch</span>(rightHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-14" title="14">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-15" title="15">        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb40-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb40-17" title="17"><span class="op">}</span></a></code></pre></div>
<h2 id="time-and-space-complexity-analysis-3">Time and Space Complexity Analysis</h2>
<p>The complexity analysis of this algorithm is easier to explain through visuals, so we <strong>highly encourage</strong> you to watch the lecture that accompanies this reading. In any case, here is a summary of the complexity:</p>
<h3 id="time-complexity-ologn">Time Complexity: O(log(n))</h3>
<ul>
<li><code>n</code> is the length of the input array</li>
<li>We have no loops, so we must only consider the number of recursive calls it takes to hit the base case</li>
<li>The number of recursive calls is the number of times we must halve the array until it’s length becomes 0. This number can be described by <code>log(n)</code>
<ul>
<li>for example, say we had an array of 8 elements, <code>n = 8</code></li>
<li>the length would halve as <code>8 -&gt; 4 -&gt; 2 -&gt; 1</code></li>
<li>it takes 3 calls, <code>log(8) = 3</code></li>
</ul></li>
</ul>
<h3 id="space-complexity-on-1">Space Complexity: O(n)</h3>
<p>Our implementation uses <code>n</code> space due to half arrays we create using slice. Note that JavaScript <code>slice</code> creates a new array, so it requires additional memory to be allocated.</p>
<h3 id="when-should-we-use-binary-search">When should we use Binary Search?</h3>
<p>Use this algorithm when the input data is sorted!!! This is a heavy requirement, but if you have it, you’ll have an insanely fast algorithm. Of course, you can use one of your high-functioning sorting algorithms to sort the input and <em>then</em> perform the binary search!</p>
<hr />
<h1 id="bubble-sort-1">Bubble Sort</h1>
<p>This project contains a skeleton for you to implement Bubble Sort. In the file <strong>lib/bubble_sort.js</strong>, you should implement the Bubble Sort. This is a description of how the Bubble Sort works (and is also in the code file).</p>
<pre><code>Bubble Sort: (array)
  n := length(array)
  repeat
    swapped = false
    for i := 1 to n - 1 inclusive do

      /* if this pair is out of order */
      if array[i - 1] &gt; array[i] then

        /* swap them and remember something changed */
        swap(array, i - 1, i)
        swapped := true

      end if
    end for
  until not swapped</code></pre>
<h2 id="instructions">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-bubble-sort-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/bubble_sort.js</code> that implements the Bubble Sort.</li>
</ul>
<hr />
<h1 id="selection-sort-1">Selection Sort</h1>
<p>This project contains a skeleton for you to implement Selection Sort. In the file <strong>lib/selection_sort.js</strong>, you should implement the Selection Sort. You can use the same <code>swap</code> function from Bubble Sort; however, try to implement it on your own, first.</p>
<p>The algorithm can be summarized as the following:</p>
<ol type="1">
<li>Set MIN to location 0</li>
<li>Search the minimum element in the list</li>
<li>Swap with value at location MIN</li>
<li>Increment MIN to point to next element</li>
<li>Repeat until list is sorted</li>
</ol>
<p>This is a description of how the Selection Sort works (and is also in the code file).</p>
<pre><code>procedure selection sort(list)
   list  : array of items
   n     : size of list

   for i = 1 to n - 1
   /* set current element as minimum*/
      min = i

      /* check the element to be minimum */

      for j = i+1 to n
         if list[j] &lt; list[min] then
            min = j;
         end if
      end for

      /* swap the minimum element with the current element*/
      if indexMin != i  then
         swap list[min] and list[i]
      end if
   end for
end procedure</code></pre>
<h2 id="instructions-1">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-selection-sort-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/selection_sort.js</code> that implements the Selection Sort.</li>
</ul>
<hr />
<h1 id="insertion-sort-1">Insertion Sort</h1>
<p>This project contains a skeleton for you to implement Insertion Sort. In the file <strong>lib/insertion_sort.js</strong>, you should implement the Insertion Sort.</p>
<p>The algorithm can be summarized as the following:</p>
<ol type="1">
<li>If it is the first element, it is already sorted. return 1;</li>
<li>Pick next element</li>
<li>Compare with all elements in the sorted sub-list</li>
<li>Shift all the elements in the sorted sub-list that is greater than the value to be sorted</li>
<li>Insert the value</li>
<li>Repeat until list is sorted</li>
</ol>
<p>This is a description of how the Insertion Sort works (and is also in the code file).</p>
<pre><code>procedure insertionSort( A : array of items )
   int holePosition
   int valueToInsert

   for i = 1 to length(A) inclusive do:

      /* select value to be inserted */
      valueToInsert = A[i]
      holePosition = i

      /*locate hole position for the element to be inserted */

      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:
         A[holePosition] = A[holePosition-1]
         holePosition = holePosition -1
      end while

      /* insert the number at hole position */
      A[holePosition] = valueToInsert

   end for

end procedure</code></pre>
<h2 id="instructions-2">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-insertion-sort-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/insertion_sort.js</code> that implements the Insertion Sort.</li>
</ul>
<hr />
<h1 id="merge-sort-1">Merge Sort</h1>
<p>This project contains a skeleton for you to implement Merge Sort. In the file <strong>lib/merge_sort.js</strong>, you should implement the Merge Sort.</p>
<p>The algorithm can be summarized as the following:</p>
<ol type="1">
<li>if there is only one element in the list, it is already sorted. return that array.</li>
<li>otherwise, divide the list recursively into two halves until it can no more be divided.</li>
<li>merge the smaller lists into new list in sorted order.</li>
</ol>
<p>This is a description of how the Merge Sort works (and is also in the code file).</p>
<pre><code>procedure mergesort( a as array )
   if ( n == 1 ) return a

   /* Split the array into two */
   var l1 as array = a[0] ... a[n/2]
   var l2 as array = a[n/2+1] ... a[n]

   l1 = mergesort( l1 )
   l2 = mergesort( l2 )

   return merge( l1, l2 )
end procedure

procedure merge( a as array, b as array )
   var result as array
   while ( a and b have elements )
      if ( a[0] &gt; b[0] )
         add b[0] to the end of result
         remove b[0] from b
      else
         add a[0] to the end of result
         remove a[0] from a
      end if
   end while

   while ( a has elements )
      add a[0] to the end of result
      remove a[0] from a
   end while

   while ( b has elements )
      add b[0] to the end of result
      remove b[0] from b
   end while

   return result
end procedure</code></pre>
<h2 id="instructions-3">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-merge-sort-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/merge_sort.js</code> that implements the Merge Sort.</li>
</ul>
<hr />
<h1 id="quick-sort-2">Quick Sort</h1>
<p>This project contains a skeleton for you to implement Quick Sort. In the file <strong>lib/quick_sort.js</strong>, you should implement the Quick Sort. This is a description of how the Quick Sort works (and is also in the code file).</p>
<pre><code>procedure quick sort (array)
  if the length of the array is 0 or 1, return the array

  set the pivot to the first element of the array
  remove the first element of the array

  put all values less than the pivot value into an array called left
  put all values greater than the pivot value into an array called right

  call quick sort on left and assign the return value to leftSorted
  call quick sort on right and assign the return value to rightSorted

  return the concatenation of leftSorted, the pivot value, and rightSorted
end procedure quick sort</code></pre>
<h2 id="instructions-4">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-quick-sort-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/quick_sort.js</code> that implements the Quick Sort.</li>
</ul>
<hr />
<h1 id="binary-search-2">Binary Search</h1>
<p>This project contains a skeleton for you to implement Binary Search. In the file <strong>lib/binary_search.js</strong>, you should implement the Binary Search and its cousin Binary Search Index.</p>
<p>The Binary Search algorithm can be summarized as the following:</p>
<ol type="1">
<li>If the array is empty, then return false</li>
<li>Check the value in the middle of the array against the target value</li>
<li>If the value is equal to the target value, then return true</li>
<li>If the value is less than the target value, then return the binary search on the left half of the array for the target</li>
<li>If the value is greater than the target value, then return the binary search on the right half of the array for the target</li>
</ol>
<p>This is a description of how the Binary Search works (and is also in the code file).</p>
<pre><code>procedure binary search (list, target)
  parameter list: a list of sorted value
  parameter target: the value to search for

  if the list has zero length, then return false

  determine the slice point:
    if the list has an even number of elements,
      the slice point is the number of elements
      divided by two
    if the list has an odd number of elements,
      the slice point is the number of elements
      minus one divided by two

  create an list of the elements from 0 to the
    slice point, not including the slice point,
    which is known as the &quot;left half&quot;
  create an list of the elements from the
    slice point to the end of the list which is
    known as the &quot;right half&quot;

  if the target is less than the value in the
    original array at the slice point, then
    return the binary search of the &quot;left half&quot;
    and the target
  if the target is greater than the value in the
    original array at the slice point, then
    return the binary search of the &quot;right half&quot;
    and the target
  if neither of those is true, return true
end procedure binary search</code></pre>
<p>Then you need to adapt that to return <em>the index</em> of the found item rather than a Boolean value. The pseudocode is also in the code file.</p>
<pre><code>procedure binary search index(list, target, low, high)
  parameter list: a list of sorted value
  parameter target: the value to search for
  parameter low: the lower index for the search
  parameter high: the upper index for the search

  if low is equal to high, then return -1 to indicate
    that the value was not found

  determine the slice point:
    if the list between the high index and the low index
    has an even number of elements,
      the slice point is the number of elements
      between high and low divided by two
    if the list between the high index and the low index
    has an odd number of elements,
      the slice point is the number of elements
      between high and low minus one, divided by two

  if the target is less than the value in the
    original array at the slice point, then
    return the binary search of the array,
    the target, low, and the slice point
  if the target is greater than the value in the
    original array at the slice point, then return
    the binary search of the array, the target,
    the slice point plus one, and high
  if neither of those is true, return the slice point
end procedure binary search index</code></pre>
<h2 id="instructions-5">Instructions</h2>
<ul>
<li>Clone the project from https://github.com/appacademy-starters/algorithms-binary-search-starter.</li>
<li><code>cd</code> into the project folder</li>
<li><code>npm install</code> to install dependencies in the project root directory</li>
<li><code>npm test</code> to run the specs</li>
<li>You can view the test cases in <code>/test/test.js</code>. Your job is to write code in the <code>/lib/binary_search.js</code> that implements the Binary Search and Binary Search Index.</li>
</ul>
</body></html>
